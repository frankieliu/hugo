<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site  | Tree Depth - USACO Platimum Dec19</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.62.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="https://www.frankliu.org/hugo/dist/css/app.3f5912c237ddd38c8e76debe081c7ca7.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Tree Depth - USACO Platimum Dec19" />
<meta property="og:description" content="This is a commentary on the solution from Benjamin Qi.
from permutation to tree generation Before we go into the solution of this problem it is good to be able to understand how to create trees using a permutation.
First how does a permutation \(a\) translate into a tree? Think of \(a[i]\) as the time in which node \(i\) is inserted to the tree. We&#39;ll use the following \(a=42315\) for illustration." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.frankliu.org/hugo/posts/usaco-dec-2019-plat-tree-depth/" />
<meta property="article:published_time" content="2020-01-15T18:21:28-08:00" />
<meta property="article:modified_time" content="2020-01-16T22:57:28-08:00" />
<meta itemprop="name" content="Tree Depth - USACO Platimum Dec19">
<meta itemprop="description" content="This is a commentary on the solution from Benjamin Qi.
from permutation to tree generation Before we go into the solution of this problem it is good to be able to understand how to create trees using a permutation.
First how does a permutation \(a\) translate into a tree? Think of \(a[i]\) as the time in which node \(i\) is inserted to the tree. We&#39;ll use the following \(a=42315\) for illustration.">
<meta itemprop="datePublished" content="2020-01-15T18:21:28-08:00" />
<meta itemprop="dateModified" content="2020-01-16T22:57:28-08:00" />
<meta itemprop="wordCount" content="1861">



<meta itemprop="keywords" content="generating functions,trees,permutations," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tree Depth - USACO Platimum Dec19"/>
<meta name="twitter:description" content="This is a commentary on the solution from Benjamin Qi.
from permutation to tree generation Before we go into the solution of this problem it is good to be able to understand how to create trees using a permutation.
First how does a permutation \(a\) translate into a tree? Think of \(a[i]\) as the time in which node \(i\) is inserted to the tree. We&#39;ll use the following \(a=42315\) for illustration."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://www.frankliu.org/hugo/" class="f3 fw2 hover-white no-underline white-90 dib">
      My New Hugo Site
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://www.frankliu.org/hugo/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://www.frankliu.org/hugo/posts/" title="Articles page">
              Articles
            </a>
          </li>
          
        </ul>
      
      













    </div>
  </div>
</nav>

    </div>
  </header>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
    extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
    });
</script>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        ARTICLES
      </p>
      <h1 class="f1 athelas mb1">Tree Depth - USACO Platimum Dec19</h1>
      
      <p class="tracked">
          By <strong>
          
              adam
          
          </strong>
      </p>
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-01-15T18:21:28-08:00">January 15, 2020</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>This is a commentary on the solution from Benjamin Qi.</p>
<h2 id="from-permutation-to-tree-generation">from permutation to tree generation</h2>
<p>Before we go into the solution of this problem it is good to be able to
understand how to create trees using a permutation.</p>
<p>First how does a permutation \(a\) translate into a tree? Think of \(a[i]\) as the
time in which node \(i\) is inserted to the tree. We'll use the following
\(a=42315\) for illustration. Assume \(1\) indexing to refer to both the index in
\(a\) and also the node number.</p>
<p>Then since \(a[4] = 1\) then node \(4\) be inserted first, becoming the root. This
divides the tree into two parts (it is a BST). Since there is only one more node
to the right of node \(4\) we will just add node \(5\) as a right child of node \(4\).</p>
<p>For the left subtree, again we find the next smaller index, in this case \(a[2]\),
this means that node \(2\) will be the left child of node \(4\). Since there are
only two remaining nodes on the either side of node \(2\), nodes \(1\) and \(3\) will
be on both left and right braches from node \(2\) respectively.</p>
<h2 id="from-permutation--a--to-depth-of-nodes">from permutation \(a\) to depth of nodes</h2>
<p>Let's take node \(3\) in the example above. Node \(3\) is at a depth of \(3\) (note
the depth of root is \(1\) according to the problem). Looking to the left of node
\(3\), only node \(2\) can be a possible ancestor of node \(3\), since node \(2\) comes
before node \(3\) (\(a[2] &lt; a[3]\)). One can make a similar argument to the right of
\(3\), node \(4\) can be an ancestor of \(3\), since \(a[4] &lt; a[3]\). Since node \(3\) is
a descendant of two nodes \(2\) and \(4\) its depth must be \(3\). One might argue that
it is possible that node \(2\) lies on one branch of node \(4\) and node \(3\) lies in
another branch of node \(4\). This is not possible because both nodes \(2\) and \(3\)
lie on the same subtree since they both come after node \(4\) and lie to the same
side of node \(4\).</p>
<p>Note the independence of left and right sides from the previous statement, it
doesn't matter whether node \(2\) is below or above node \(4\) from \(3\)&lsquo;s
perspective, it only needs to know how many ancestors are above it. This will
come in handy later.</p>
<p>Node \(3\) was kind of obvious, we look to the left and right and found two nodes
that were ancestors to it. If we examine node \(1\) it is a little bit more
tricky. If you apply the same logic as before, nodes \(2,3,4\) all have \(a[2 .. 4]
&lt; a[1]\) they all could be potential ancestors for \(1\). If you think of them in
order, however, you will note the following. For \(a[4]\), it is clear that it is
the root, everything to its right is irrelevant to \(1\). For \(3\) it is not clear
whether it is an ancestor of \(1\). Node \(1\) could potentially lie on \(3\)&lsquo;s left
branch from its positioning, unless there is a node between \(3\) and \(1\) that
separates them into separate branches. Indeed there is such a node: \(2\). Node
\(2\) comes before \(3\) and therefore separates \(1\) from \(3\) into different
subtrees. In fact when examining node \(3\) we just have to find a node \(j\)
between \(1\) and \(3\) such that \(a[j] &lt; a[3]\). To simplify further, we need to
look for the minimum node \(j\) between \(1\) and \(3\) to separate the two sides,
potentially discarding further possibilities.</p>
<p>So in general when we look for the possible ancestors of a particular node \(i\),
when considering a node \(j &lt; i\) as a potential candidate, we only need to find
the some minimum between \(a[j .. i]\) to determine if node \(j\) could be a
potential ancestor. This is symmetric for a point \(j\) to the right of \(i\).</p>
<p>Thus one comes to the following formula in the solution:</p>
<p>\[
d_i(a)=1+\sum_{1\le j&lt;i}(a[j] == \min(a[j\ldots i]))+\sum_{i&lt;j\le n}(a[j] ==
\min(a[i\ldots j])).
\]</p>
<p>The first \(1\) on the RHS, denotes the default depth of the root, then
the first sum denotes the elements to the left of node \(i\) and the second sum
denotes the elements to the right of node \(i\).   It would have been a little bit
clearer to add an indicator function in front of the condition.</p>
<p>\[
d_i(a)=1+\sum_{1\le j&lt;i}\mathbf{1}(a[j] == \min(a[j\ldots i]))+\sum_{i&lt;j\le n}\mathbf{1}(a[j] ==
\min(a[i\ldots j])).
\]</p>
<h2 id="independence-property">independence property</h2>
<p>We have already alluded that \(\min(a[j\ldots i])\) and \(\min(a[i\ldots j])\) count
independently from one another.  This means that there might be an single
permutation that contains both a left and right ancestor for node \(i\).  These
two need to be counted twice, even though they come from the same permutation.
In other words, we are free to sum up allowable permutations for left
independently from the allowable permutations for the right, even if they
are the same permutation (i.e. because of independence there is no overcounting).</p>
<p>On the other hand we have to be careful about counting \(\min(a[j\dots i])\) (and
by symmetry on the other side) points that lie on the same side. Suppose there
are two points \(j&rsquo;\) and \(j\) where \(j&rsquo; &lt; j\), that is, \(j&rsquo;\) is to the left of \(j\).
Since \(a[j&rsquo;]\) is a minimum from \(j&rsquo;\) to \(i\), we cannot count permutations that
include \(j\) as the mininum. On the other hand if \(a[j]\) is the minimum from \(j\)
to \(i\), then it does not matter whether \(j&rsquo;\) is a minimum, why? If \(a[j&rsquo;] &lt;
a[j]\) then those permutations would have been counted when considering \(a[j&rsquo;]\)
and they count separately from the contributions of node \(j\). If \(a[j&rsquo;] &gt; a[j]\)
then node \(j&rsquo;\) would not been a potential ancestor. Thus one can see that
&ldquo;outer&rdquo; ancestors must exclude the possibility of smaller &ldquo;inner&rdquo; ancestors,
since by definition the &ldquo;outer&rdquo; ancestor comes earlier than any other
&ldquo;inner&rdquo; ancestor.  By exclusion I only mean that we cannot count permutations
at allow \(a[j]&lt;a[j&rsquo;]\) when considering node \(j&rsquo;\) as a possible ancestor of node
\(i\).  Of course when considering node \(j\) as a possible ancestor we are free
to include permutations unconstrained on the value of \(a[j&rsquo;]\).</p>
<h2 id="generating-functions-to-count-inversions">generating functions to count inversions</h2>
<p>With the independence property, we can now independently consider contributions
of depth to a particular node, say node \(i\).  For a particular node \(i\) we will
also consider a particular node \(j\) that is a potential ancestor and tabulate
how many permutations have node \(j\) as \(i\)&lsquo;s ancestor.  We are free to tabulate
all these permutations as long as they follow two rules.</p>
<p>One, the total number of inversions has to be \(k\) and two, for these
permutations there are no node smaller than \(a[j]\) for nodes in \(i\ldots j\).</p>
<p>We can count the number of permutations available by counting the possible
inversions at each index.  For example at index \(i\) there is only one possible
inversion, namely \(0\), since this is a reference point.  For \(i+1\), there are two
possible inversions, \(a[i]\) and \(a[i+1]\) are either in order or not.  For \(i+2\)
there are three possible inversions, and so on.  Each of these possibilities can
be captured by a generating function, and the combined convolution of these
possibilities captured as the product of the individual sums as
\((x_0)(x_0+x_1)(x_0+x_1+x_2)\cdots(x_0+x_1+\ldots+x_{j-1})\).  At \(j\), we know
that the \(a[j] == min(a[i\ldots j]\) therefore there is only one possibility for
the \(j\) term, \(j\) inversions or \(x_j\).  for the \(j+1\) term, it is allowed to
have any number of inversions, since there is no restriction on its value.  If
\(a[j+1]\) is smaller than \(a[j]\) then this scenario will be counted when
setting \(j\) to this number, and as we mentioned before the permutations of this
&ldquo;outer&rdquo; ancestor does not precude the counting of &ldquo;inner&rdquo; ancestors.  This
continues until \(a[j + (n-j)]\) for which there are \(0\) to \(n-i+1\) inversions
possible.</p>
<p>Next we continue counting on the left side of \(a[i]\), for \(a[i-1]\). This doesn't
have any restrictions and therefore we can consider inversions fomr \(i-1\) to
\(n\), with a possibility of \(0\) to \(n-i+2\) inversions.  Note that this way of
enumerating inversions by looking at only possibilities to the right of number
ensures that no inversion is missed, or overcounted.  We continue in this
fashion until \(a[i-(i-1)]\) which can have \(0\) to \(n-1\) inversions.</p>
<p>Thus the accounting of all possible number of permutations for each number of
inversion is capture in the coefficient of the \(x_k\) term of the polynomial.
The effect of the \(j\) th term can be separated by multiplying by</p>
<p>\[
\frac{x_0 + x_1 + \ldots + x_{j-i}}{x_0 + x_1 + \ldots + x_{j-i}}
\]</p>
<p>Thus arriving at</p>
<p>\[
\prod_{t=1}^{n}\left(\sum_{u=0}^{t-1}x^u\right)\cdot
\frac{1}{\sum_{u=0}^{j-i}x^u}\cdot x^{j-i}.
\]</p>
<h2 id="convolution-with-rectangles">convolution with rectangles</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ad</span>(vmi<span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">int</span> b) { <span style="color:#75715e">// multiply by (x^0+x^1+...+x^{b-1})
</span><span style="color:#75715e"></span>  a.rsz(sz(a)<span style="color:#f92672">+</span>b<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  R0F(i,sz(a)<span style="color:#f92672">-</span>b) a[i<span style="color:#f92672">+</span>b] <span style="color:#f92672">-</span><span style="color:#f92672">=</span> a[i];
  FOR(i,<span style="color:#ae81ff">1</span>,sz(a)) a[i] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> a[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
}
</code></pre></div><p>The easiest way to to think about this convolution is as a sliding window of
length \(b\).  As in a sliding window, it is easier keep a running sum, and
sliding the window remove one item from the back and insert a new element at
the front.  The only thing that this does differently is removing the
prior to computing the running sum.</p>
<p>Another way to think about a convolution with a rectangle is a convolution with
a superposition of step functions.</p>
<p>\[
{\displaystyle \Pi\left({\frac {t-X}{Y}}\right)=u(t-(X-Y/2))-u(t-(X+Y/2))}
\]</p>
<p>Further if we recognize the step function as the integral of a delta function:</p>
<p>\[
{\displaystyle H(x):=\int _{-\infty }^{x}{\delta (s)}\ ds}
\]</p>
<p>Then we can first convolve with the delta function followed by an integral.</p>
<p>\begin{aligned}
f * \Pi((x-b/2)/b) &amp;= f * (H(x) - H(x-b)) \\\<br>
&amp;= \int_{-\infty}^{x} f * (\delta(s) - \delta(s-b))\ ds\\\<br>
&amp;= \int f(s) - f(s-b)\ ds
\end{aligned}</p>
<p>Thus the function in the code shifts \(a[]\) by \(b\) adds it to \(a[]\) and then
calculates a prefix sum.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sub</span>(vmi<span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">int</span> b) {
  ROF(i,<span style="color:#ae81ff">1</span>,sz(a)) a[i] <span style="color:#f92672">-</span><span style="color:#f92672">=</span> a[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
  F0R(i,sz(a)<span style="color:#f92672">-</span>b) a[i<span style="color:#f92672">+</span>b] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> a[i];
  a.rsz(sz(a)<span style="color:#f92672">-</span>b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>The <code>sub</code> function does the exact opposite, it differentiates \(a[]\) then adds
back a shifted amount back.  This corresponds to dividing by the polynomial
\((x_0 + \ldots + x_{j-i})\)</p>
<h2 id="left-and-right">left and right</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  setIO(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">treedepth</span><span style="color:#e6db74">&#34;</span>);
  cin <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> n <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> k <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> MOD;
  vmi v <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>}; FOR(i,<span style="color:#ae81ff">1</span>,n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) ad(v,i);
  vmi ans(n,v[k]);
  FOR(dif,<span style="color:#ae81ff">1</span>,n) {
    sub(v,dif<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    mi x <span style="color:#f92672">=</span> get(v,k<span style="color:#f92672">-</span>dif), y <span style="color:#f92672">=</span> get(v,k);
    ad(v,dif<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    F0R(a,n<span style="color:#f92672">-</span>dif) {
      ans[a] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> x;
      ans[a<span style="color:#f92672">+</span>dif] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> y;
    }
  }
  F0R(i,n) cout <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> ans[i].val <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#39;</span>;
}
</code></pre></div><p>The first \(~ad\) basically sets up the generating for all permutations.
Then we populate the answer with all the permutations with \(k\) inversions.  This
corresponds to adding the \(1\) in \(d_i(a)\).  Then we remove a set of permutations
containing \(0\) to \(|j-i|\) inversions.  <code>x</code> corresponds \(j&gt;i\) for which we
need to take into account the inversions for the \(j\) th element.  And <code>y</code>
correponds \(j&lt;i\) for which there are no inversions caused by element \(j\).
These two steps can be thought as adding the right most two terms in \(d_i(a)\).
However, for a particular \(i\) this is not done at the same time, but eventually
all \(|j-i|\) are considered in the innermost for loop.</p>
<p>Credits, thanks Benjamin, Anup, and Santosh.</p>
<ul class="pa0">
  
   <li class="list">
     <a href="https://www.frankliu.org/hugo/tags/generating-functions" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">generating functions</a>
   </li>
  
   <li class="list">
     <a href="https://www.frankliu.org/hugo/tags/trees" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">trees</a>
   </li>
  
   <li class="list">
     <a href="https://www.frankliu.org/hugo/tags/permutations" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">permutations</a>
   </li>
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.frankliu.org/hugo/" >
    &copy;  My New Hugo Site 2020 
  </a>
    <div>












</div>
  </div>
</footer>

    

  <script src="https://www.frankliu.org/hugo/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
