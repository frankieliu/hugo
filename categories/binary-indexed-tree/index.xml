<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>binary indexed tree on My New Hugo Site</title>
    <link>https://www.frankliu.org/hugo/categories/binary-indexed-tree/</link>
    <description>Recent content in binary indexed tree on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Jun 2020 15:22:25 -0700</lastBuildDate>
    
	<atom:link href="https://www.frankliu.org/hugo/categories/binary-indexed-tree/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Codeforces Till-I-Collapse (Part III)</title>
      <link>https://www.frankliu.org/hugo/posts/till-i-collapse-iii/</link>
      <pubDate>Tue, 30 Jun 2020 15:22:25 -0700</pubDate>
      
      <guid>https://www.frankliu.org/hugo/posts/till-i-collapse-iii/</guid>
      <description>extent of region We begin with the segment tree version. Note that Ershov uses a version of the segment tree where the right side of the range of responsibility is open, i.e. \([3,4)\) is equivalent to \([3,3]\)
The function get below will find the size of the largest range whose prefix sum is \(k\).
int get(int v, int vl, int vr, int &amp;amp;k) { if (k &amp;gt;= st[v]) { k -= st[v]; return vr - vl; } if (vl == vr - 1) { return 0; } int mid = (vl + vr) / 2; int res = get(v * 2, vl, mid, k); if (res == mid - vl) { res += get(v * 2 + 1, mid, vr, k); } return res; } It does so by allowing the \(k\) to go down to \(0\), while there are empty ranges the recursion goes to the right child, until it reaches a single element range containing an element (\(&amp;gt;0\)) at which point it returns \(0\).</description>
    </item>
    
    <item>
      <title>Codeforces Till-I-Collapse (Part II)</title>
      <link>https://www.frankliu.org/hugo/posts/till-i-collapse-ii/</link>
      <pubDate>Mon, 29 Jun 2020 14:14:24 -0700</pubDate>
      
      <guid>https://www.frankliu.org/hugo/posts/till-i-collapse-ii/</guid>
      <description>credits It is interesting that MiFaFAOvO&amp;rsquo;s solution has the same pieces are ershov.stanislav&amp;rsquo;s solution. In fact they both use the worm method (my own naming for subsequence like states). What is interesting from MiFaFAOvO&amp;rsquo;s solution is that he uses a BIT to solve the problem.
what kind of tree is a BIT While the update part of a BIT is pretty straightforward one may wonder at the reverse query part which was done in ershov&amp;rsquo;s solution \(O(\log n)\).</description>
    </item>
    
  </channel>
</rss>