<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on My New Hugo Site</title>
    <link>https://www.frankliu.org/hugo/categories/leetcode/</link>
    <description>Recent content in leetcode on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Nov 2019 14:40:38 -0800</lastBuildDate>
    
	<atom:link href="https://www.frankliu.org/hugo/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 460. LFU Cache</title>
      <link>https://www.frankliu.org/hugo/posts/460-lfu-cache/</link>
      <pubDate>Mon, 18 Nov 2019 14:40:38 -0800</pubDate>
      
      <guid>https://www.frankliu.org/hugo/posts/460-lfu-cache/</guid>
      <description>Requirements  O(1) insertion  requires O(1) getting the least frequently used   Suggested data structures  f: a map from frequency to a tuple containing the head and tail of a portion of a double linked list kv: a map from key to a node in the double linked list dll: a double linked list where the least frequent item is at the head of the list node: element of dll, containing frequency info, as well a prev, next, value, the usual stuff    put(a,v)  find corresponding node via kv[a] delete node from its current position and insert it at the head of the next frequency, i.</description>
    </item>
    
    <item>
      <title>731 My Calendar II</title>
      <link>https://www.frankliu.org/hugo/posts/731-my-calendar-ii-segment-tree/</link>
      <pubDate>Thu, 03 Oct 2019 20:56:27 -0700</pubDate>
      
      <guid>https://www.frankliu.org/hugo/posts/731-my-calendar-ii-segment-tree/</guid>
      <description>Acknowledgement Taken from fun4leet&amp;rsquo;s My Calendar II wonderful article
tl;dr A max segment tree, with an incremental update function is sufficient for this problem. Max is used because such tree allows quick query of the max number of bookings given a range. Incremental update is useful because each time book is called, one needs to increment the bookings in a particular range.
Data structure 4 things: a range \([l,r]\), data, lazy flag</description>
    </item>
    
    <item>
      <title>920 Number of music playlists</title>
      <link>https://www.frankliu.org/hugo/posts/920-number-of-music-playlists/</link>
      <pubDate>Fri, 30 Aug 2019 19:13:32 -0700</pubDate>
      
      <guid>https://www.frankliu.org/hugo/posts/920-number-of-music-playlists/</guid>
      <description>Notes on solution to Leetcode 920 Let&amp;rsquo;s take the example from the article, songs: \(\left\{abcde\right\}\), playlist: \(abacabdcbaeacbd\),
\(\bar{x} = (1,2,4,7,11)\)
For \(\bar{x}\), each number in the n-tuple indicates a position in the playlist for the first occurrence of a particular unique song. The article uses 1-indexing so I will use the same to be consistent.
As an example for the \(\bar{x}\) above, consider the playlist family:
\(p_l = (1_1,2_2,c_3,3_4,c_5,c_6,4_7,c_8,c_9,c_{10},5_{11},c_{12},c_{13},c_{14})\)</description>
    </item>
    
  </channel>
</rss>