<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>segment tree on My New Hugo Site</title>
    <link>https://www.frankliu.org/hugo/categories/segment-tree/</link>
    <description>Recent content in segment tree on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 29 Jun 2020 14:14:24 -0700</lastBuildDate>
    
	<atom:link href="https://www.frankliu.org/hugo/categories/segment-tree/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Codeforces Till-I-Collapse (Part II)</title>
      <link>https://www.frankliu.org/hugo/posts/till-i-collapse-ii/</link>
      <pubDate>Mon, 29 Jun 2020 14:14:24 -0700</pubDate>
      
      <guid>https://www.frankliu.org/hugo/posts/till-i-collapse-ii/</guid>
      <description>credits It is interesting that MiFaFAOvO&amp;rsquo;s solution has the same pieces are ershov.stanislav&amp;rsquo;s solution. In fact they both use the worm method (my own naming for subsequence like states). What is interesting from MiFaFAOvO&amp;rsquo;s solution is that he uses a BIT to solve the problem.
what kind of tree is a BIT While the update part of a BIT is pretty straightforward one may wonder at the reverse query part which was done in ershov&amp;rsquo;s solution \(O(\log n)\).</description>
    </item>
    
    <item>
      <title>Codeforces Till-I-Collapse</title>
      <link>https://www.frankliu.org/hugo/posts/till-i-collapse/</link>
      <pubDate>Sun, 28 Jun 2020 06:56:36 -0700</pubDate>
      
      <guid>https://www.frankliu.org/hugo/posts/till-i-collapse/</guid>
      <description>credit This is ershov.stanislav&amp;rsquo;s solution to the problem.
summary of problem Given an array of integers (colors), find the mininum nunber of consecutive grouping containing at most \(k\) colors (number of unique integers in a subarray).
greedy For a single \(k\) one can take \(O(n)\) time to greedily scan through the array and accumulate \(k\) unique integers at a time.
problem size However, given the size of the problem (\(10^5\)) and the fact that we must do this for \(k \in {1,\cdots,n}\) implies that we must look for a better solution.</description>
    </item>
    
    <item>
      <title>Errichto - segment tree</title>
      <link>https://www.frankliu.org/hugo/posts/ericcto-segment-tree/</link>
      <pubDate>Fri, 07 Feb 2020 16:03:25 -0800</pubDate>
      
      <guid>https://www.frankliu.org/hugo/posts/ericcto-segment-tree/</guid>
      <description>Segment tree   Preliminaries The data structure in this segment tree information according to Antti Laaksonen in the Competitive Programmer&amp;rsquo;s Handbook comes from
[62] P. Sta≈Ñczyk. Algorytmika praktyczna w konkursach Informatycznych, MSc thesis, University of Warsaw, 2006.
Basically the original range is stored at some offset that correspond to largest power of two that is greater or equal to the size of the range. For example a size 16 array would be stored at an offset of 16 in the array.</description>
    </item>
    
  </channel>
</rss>